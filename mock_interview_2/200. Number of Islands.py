from typing import List
from collections import deque


# не получилось понять, почему код с обходом в ширину падает по времени на 39 из 49 тестов
# поэтому только через обход в глубину
# так же возможно решение через disjoinSet
class Solution:
    # обход в глубину со стеком
    def numIslands(self, grid: List[List[str]]) -> int:
        m = len(grid)
        n = len(grid[0])
        island_count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    island_count += 1
                    self.checkIsland(grid, i, j)
        return island_count

    def checkIsland(self, grid: List[List[int]], row: int, col: int) -> None:
        m = len(grid)
        n = len(grid[0])
        drow = [0, 1, 0, -1]
        dcol = [1, 0, -1, 0]
        stack = [(row, col)]
        while stack:
            row, col = stack.pop()
            grid[row][col] += "-" + grid[row][col]

            for i, j in zip(drow, dcol):
                if 0 <= row + i < m and 0 <= col + j < n and grid[row + i][col + j] == "1":
                    stack.append((row + i, col + j))


class Solution_1:
    # рекурсивный обход в глубину
    def numIslands(self, grid: List[List[str]]) -> int:
        m = len(grid)
        n = len(grid[0])
        island_count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    island_count += 1
                    self.checkIsland(grid, i, j)
        return island_count

    def checkIsland(self, grid: List[List[int]], row: int, col: int) -> None:
        m = len(grid)
        n = len(grid[0])
        grid[row][col] = "-" + grid[row][col]
        drow = [0, 1, 0, -1]
        dcol = [1, 0, -1, 0]
        for i, j in zip(drow, dcol):
            if 0 <= row + i < m and 0 <= col + j < n and grid[row + i][col + j] == "1":
                self.checkIsland(grid, row + i, col + j)


s = Solution()
print(
    s.numIslands(
        [["1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", "1"],
         ["0", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "0", "1", "1", "1", "1", "1", "0"],
         ["1", "0", "1", "1", "1", "0", "0", "1", "1", "0",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "0", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "0", "0", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "0", "1", "1", "1", "1", "1", "1", "0", "1",
             "1", "1", "0", "1", "1", "1", "0", "1", "1", "1"],
         ["0", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "0", "1", "1", "0", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "0", "1", "1", "1", "1", "0", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "0", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["0", "1", "1", "1", "1", "1", "1", "1", "0", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "0", "1", "1", "1", "1",
             "1", "1", "1", "0", "1", "1", "1", "1", "1", "1"],
         ["1", "0", "1", "1", "1", "1", "1", "0", "1", "1",
             "1", "0", "1", "1", "1", "1", "0", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "0", "1", "1", "1", "1", "1", "1", "0"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "0", "1", "1", "1", "1", "0", "0"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
             "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
         ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]]
    )
)
